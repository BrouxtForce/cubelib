class l{#Q;#Z;constructor(Q,Z=!1){this.#Q=Z?Q.copy().invert():Q,this.#Z=!1}next(){let Q;if(this.#Z)Q={done:!0,value:void 0};else Q={done:!1,value:this.#Q},this.#Z=!0;return Q}}class c{#Q;#Z;#W;#J;constructor(Q,Z=!1){this.#Q=Z?4:0,this.#Z=Q.algA,this.#W=Q.algB,Z=Z!==Q.amount<0,this.#J=new f(Z?this.#W:this.#Z)}next(){const Q=this.#J.next();if(Q.done){switch(this.#Q++,this.#Q){case 1:this.#J=new f(this.#W);break;case 2:this.#J=new f(this.#Z,!0);break;case 3:this.#J=new f(this.#W,!0);break;case 5:this.#J=new f(this.#Z);break;case 6:this.#J=new f(this.#W,!0);break;case 7:this.#J=new f(this.#Z,!0);break;case 4:case 8:return{done:!0,value:void 0}}return this.#J.next()}return Q}}class d{#Q;#Z;#W;#J;#K;constructor(Q,Z=!1){this.#Q=0,this.#Z=Q.algA,this.#W=Q.algB,this.#K=Z!==Q.amount<0,this.#J=new f(this.#Z)}next(){const Q=this.#J.next();if(Q.done){switch(this.#Q++,this.#Q){case 1:this.#J=new f(this.#W,this.#K);break;case 2:this.#J=new f(this.#Z,!0);break;case 3:return{done:!0,value:void 0}}return this.#J.next()}return Q}}class f{#Q;#Z;#W;#J;#K;constructor(Q,Z=!1){this.#K=Z!==Q.amount<0,this.#Q=this.#K?Q.nodes.length-1:0,this.#Z=Math.abs(Q.amount),this.#W=Q.moveNodes,this.#J=this.#X(this.#W[this.#Q],this.#K)}#X(Q,Z=!1){if(!Q)return null;switch(Q.type){case"Move":return new l(Q,Z);case"Commutator":return new c(Q,Z);case"Conjugate":return new d(Q,Z);case"Alg":return new f(Q,Z);default:throw new Error(`Unknown alg move node type: ${Q.type}`)}}next(){if(this.#J){const Q=this.#J.next();if(!Q.done)return{done:!1,value:Q.value}}if(this.#Q+=this.#K?-1:1,this.#Q<this.#W.length&&!this.#K||this.#Q>=0&&this.#K)return this.#J=this.#X(this.#W[this.#Q],this.#K),this.next();if(--this.#Z>0)return this.#Q=this.#K?this.#W.length-1:0,this.#J=this.#X(this.#W[this.#Q],this.#K),this.next();return{done:!0,value:void 0}}}function s(Q,Z){return(Q%Z+Z)%Z}function y(Q,Z){if(!Q){if(Z)throw new Error(`Assertion failed: ${Z}`);throw new Error("Assertion failed")}}function v(Q,Z){y(Number.isInteger(Z),"arrayRepeat() repeat must be an integer"),y(Z>=0,"arrayRepeat() repeat must be a nonnegative integer");const W=Q.length;Q.length=Z*W;for(let J=1;J<Z;){const K=Math.min(Z-J,J);Q.copyWithin(J*W,0,K*W),J+=K}return Q}class e{type="Commutator";algA;algB;isGrouping;amount;length;constructor(Q,Z,W=1,J=!0){this.algA=Q,this.algB=Z,this.amount=W,this.isGrouping=J,this.length=2*(this.algA.length+this.algB.length)}copy(){return new e(this.algA.copy(),this.algB.copy(),this.amount,this.isGrouping)}expanded(){if(this.amount===0)return[];const Q=this.algA.expanded(),Z=this.algB.expanded(),W=[],J=[];for(let H=Q.length-1;H>=0;H--){const _=Q[H];if(_.type==="Move"){W.push(_.copy().invert());continue}W.push(_.copy())}for(let H=Z.length-1;H>=0;H--){const _=Z[H];if(_.type==="Move"){J.push(_.copy().invert());continue}J.push(_.copy())}let K;if(this.amount>0)K=Q.concat(Z,W,J);else K=Z.concat(Q,J,W);const X=K.length,q=v(K,Math.abs(this.amount));for(let H=X;H<K.length;H++)K[H]=K[H].copy();return q}expandedMoves(){if(this.amount===0)return[];const Q=this.algA.expandedMoves(),Z=this.algB.expandedMoves(),W=[],J=[];for(let H=Q.length-1;H>=0;H--)W.push(Q[H].copy().invert());for(let H=Z.length-1;H>=0;H--)J.push(Z[H].copy().invert());let K;if(this.amount>0)K=Q.concat(Z,W,J);else K=Z.concat(Q,J,W);const X=K.length,q=v(K,Math.abs(this.amount));for(let H=X;H<K.length;H++)K[H]=K[H].copy();return q}invert(){const Q=this.algA;return this.algA=this.algB,this.algB=Q,this}toString(){const Q=`[${this.algA.toString()},${this.algB.toString()}]`;if(this.isGrouping){if(Math.abs(this.amount)!==1)return`[${Q}]${this.amount}${this.amount<0?"'":""}`;return`[${Q}]${this.amount<0?"'":""}`}return Q}simplify(){if(this.algA.simplify(),this.algB.simplify(),this.amount<0){const Q=this.algA;this.algA=this.algB,this.algB=Q,this.amount*=-1}return this}forward(){return{[Symbol.iterator]:()=>new c(this)}}reverse(){return{[Symbol.iterator]:()=>new c(this,!0)}}[Symbol.iterator](){return new c(this)}}class Q0{type="Conjugate";algA;algB;isGrouping;amount;length;constructor(Q,Z,W=1,J=!0){this.algA=Q,this.algB=Z,this.amount=W,this.isGrouping=J,this.length=2*this.algA.length+this.algB.length}copy(){return new Q0(this.algA.copy(),this.algB.copy(),this.amount,this.isGrouping)}expanded(){const Q=this.algA.expanded(),Z=this.algB.expanded(),W=[];for(let X=Q.length-1;X>=0;X--){const q=Q[X];if(q.type==="Move"){W.push(q.copy().invert());continue}W.push(q.copy())}if(this.amount<0){for(let X=0;X<Z.length;X++){const q=Z[X];if(q.type==="Move")q.invert()}Z.reverse()}const J=Q.concat(Z,W),K=J.length;v(J,Math.abs(this.amount));for(let X=K;X<J.length;X++)J[X]=J[X].copy();return J}expandedMoves(){const Q=this.algA.expandedMoves(),Z=this.algB.expandedMoves(),W=[];for(let X=Q.length-1;X>=0;X--)W.push(Q[X].copy().invert());if(this.amount<0){for(let X=0;X<Z.length;X++){const q=Z[X];if(q.type==="Move")q.invert()}Z.reverse()}const J=Q.concat(Z,W),K=J.length;v(J,Math.abs(this.amount));for(let X=K;X<J.length;X++)J[X]=J[X].copy();return J}invert(){return this.algB.invert(),this}toString(){const Q=`${this.algA.toString()}:${this.algB.toString()}`;if(this.isGrouping){if(Math.abs(this.amount)!==1)return`[${Q}]${this.amount}${this.amount<0?"'":""}`;return`[${Q}]${this.amount<0?"'":""}`}return Q}simplify(){if(this.algA.simplify(),this.algB.simplify(),this.amount<0)this.algB.invert(),this.amount*=-1;return this}forward(){return{[Symbol.iterator]:()=>new d(this)}}reverse(){return{[Symbol.iterator]:()=>new d(this,!0)}}[Symbol.iterator](){return new d(this)}}class k0{#Q;pos=0;line=1;col=0;constructor(Q){this.#Q=Q}get string(){return this.#Q}next(){let Q=this.#Q.charAt(this.pos);if(this.pos++,Q==="\n")this.line++,this.col=0;else this.col++;return Q}peek(){return this.#Q.charAt(this.pos)}skip(Q){for(let Z=0;Z<Q&&this.pos<this.#Q.length;Z++)this.next()}match(Q){return this.#Q.substring(this.pos,this.pos+Q.length)===Q}eof(){return this.peek()===""}croak(Q){throw`Error Ln ${this.line} Col ${this.col}: ${Q}`}}class Z0{input;#Q=new Set;constructor(Q){this.input=new k0(Q)}isWhitespace(Q){if(!Q)return!1;return" \t\n".indexOf(Q)>-1}isPunctuation(Q){if(!Q)return!1;return"[](),:=".indexOf(Q)>-1}isMove(Q){if(!Q)return!1;return"ufrbldmesxyz".indexOf(Q.toLowerCase())>-1}isNumber(Q){if(!Q)return!1;return"0123456789".indexOf(Q)>-1}isVariable(Q){if(!Q)return!1;return Q>="a"&&Q<="z"||Q>="A"&&Q<="Z"}peekVariable(){const Q=this.input.string;for(let Z=this.input.pos;Z<Q.length;Z++){const W=Q[Z];if(W>="a"&&W<="z"||W>="A"&&W<="Z")continue;return Q.substring(this.input.pos,Z)}return Q.substring(this.input.pos)}readWhile(Q){let Z=[];while(!this.input.eof()&&Q(this.input.peek()))Z.push(this.input.next());return Z.join("")}readNumber(){return this.readWhile(this.isNumber)}readMove(){let Q="";if(this.isNumber(this.input.peek()))Q+=this.readNumber();if(this.input.peek()==="-")Q+=this.input.next(),Q+=this.readNumber();const Z=this.input.next();Q+=Z;let W=this.input.peek();if(this.isNumber(W)){if(Q+=this.readNumber(),this.input.peek()==="'")Q+=this.input.next();return Q}switch(W){case"w":if("UFRBLD".indexOf(Z)===-1)this.input.croak("Invalid move before 'w'");if(Q+=this.input.next(),this.isNumber(this.input.peek()))Q+=this.readNumber();if(this.input.peek()==="'")Q+=this.input.next();return Q;case"'":return Q+this.input.next()}return Q}readPunc(){return this.input.next()}readCommentToken(){const Q=this.input.pos,Z=this.input.line,W=this.input.col;switch(this.input.next(),this.input.peek()){case"/":return this.input.next(),{type:"lineComment",value:this.readWhile((K)=>K!=="\n"),pos:Q,line:Z,col:W};case"*":{this.input.next();let J="";while(!this.input.eof()){if(J+=this.readWhile((K)=>K!=="*"),this.input.match("*/"))return this.input.next(),this.input.next(),{type:"blockComment",value:J,pos:Q,line:Z,col:W};this.input.next()}this.input.croak("Syntax Error: Missing end to multi-line comment.")}default:this.input.croak("Syntax Error: Random forward slash.")}}readWhitespace(){return this.readWhile(this.isWhitespace)}readNext(){if(this.input.eof())return null;const Q=this.input.pos,Z=this.input.line,W=this.input.col;let J=this.input.peek();if(this.isWhitespace(J))return{type:"whitespace",value:this.readWhitespace(),pos:Q,line:Z,col:W};if(this.isVariable(J)){const K=this.peekVariable();if(this.#Q.has(K)){this.input.skip(K.length);let q=1;if(this.isNumber(this.input.peek()))q=Number.parseInt(this.readNumber());if(this.input.peek()==="'")this.input.next(),q*=-1;return{type:"variable",value:K,amount:q,pos:Q,line:Z,col:W}}const X=this.input.string;for(let q=this.input.pos+K.length;q<X.length;q++){const H=X[q];if(this.isWhitespace(H))continue;if(H==="=")return this.#Q.add(K),this.input.skip(K.length),{type:"variable",value:K,pos:Q,line:Z,col:W};break}}if(this.isMove(J)||this.isNumber(J))return{type:"move",value:this.readMove(),pos:Q,line:Z,col:W};if(this.isPunctuation(J)){let K={type:"punctuation",value:this.readPunc(),pos:Q,line:Z,col:W};if((this.isNumber(this.input.peek())||this.input.peek()==="'")&&(K.value===")"||K.value==="]")){if(K.amount=Number.parseInt(this.readNumber()),isNaN(K.amount))K.amount=1;if(this.input.peek()==="'")this.input.next(),K.amount*=-1}return K}if(J==="/")return this.readCommentToken();this.input.croak(`Syntax Error: Unexpected character: '${J}'`)}}class o{type="Move";face;shallow=1;deep=1;amount;length=1;constructor(Q,Z,W,J){this.face=Q,this.shallow=Z,this.deep=W,this.amount=J}static fromString(Q){let Z,W=1,J=1,K=1;const X=new Z0(Q);let q=X.input.peek(),H=!1;if(X.isNumber(q)){if(J=Number.parseInt(X.readNumber()),X.input.peek()==="-"){X.input.next();let _=Number.parseInt(X.readNumber());W=J,J=_,H=!0}}if(Z=X.input.next(),Z===Z.toUpperCase()&&X.input.peek()!=="w"&&!H&&J!==1)W=J;if(X.input.peek()==="w"||Z===Z.toLowerCase()){if(J===1)J=2}if("UFRBLD".indexOf(Z.toUpperCase())!==-1)Z=Z.toUpperCase();if(X.input.peek()==="w")X.input.next();if(X.isNumber(X.input.peek())&&!X.input.eof())K=Number.parseInt(X.readNumber());if(X.input.peek()==="'")X.input.next(),K*=-1;if(!Number.isSafeInteger(W)||!Number.isSafeInteger(J)||!Number.isSafeInteger(K))throw"Invalid move: Number too large to have precise behavior.";if(Z.length===0)throw"Invalid move: Face is missing.";if("UFRBLDMESmesxyz".indexOf(Z)===-1)throw"Invalid move";if(W>J)throw"Invalid move: Shallow index cannot be greater than deep index.";if(W<1)throw"Invalid move: Shallow index must be at least 1.";return new o(Z,W,J,K)}copy(){return new o(this.face,this.shallow,this.deep,this.amount)}expanded(){return[this.copy()]}expandedMoves(){return[this.copy()]}invert(){return this.amount*=-1,this}toString(){let Q="",Z=!1;if(this.deep!==1){if(Z=!0,this.shallow!==1)if(this.shallow===this.deep)Q+=this.shallow,Z=!1;else Q+=this.shallow+"-"+this.deep;else if(this.deep!==2)Q+=this.deep}if(Z)Q+=this.face.toLowerCase();else Q+=this.face;if(Math.abs(this.amount)!==1)Q+=Math.abs(this.amount);if(this.amount<0)Q+="'";return Q}simplify(){if(this.amount%=4,Math.abs(this.amount)===3)this.amount=-Math.sign(this.amount);return this}equal(Q){return s(this.amount,4)===s(Q.amount,4)&&this.face===Q.face&&this.shallow===Q.shallow&&this.deep===Q.deep}forward(){return{[Symbol.iterator]:()=>new l(this)}}reverse(){return{[Symbol.iterator]:()=>new l(this,!0)}}[Symbol.iterator](){return new l(this)}}var Y0=function(Q,Z=!1,W=!1){let J=[];while(!0){const K=Q.next();if(!K)break;const{pos:X,line:q,col:H}=K;if(K.type==="move"){J.push(o.fromString(K.value));continue}if(K.type==="variable"){const _=L0.get(K.value);if(!_){m.push({message:`Undefined variable '${K.value}'`,pos:X,line:q,col:H});continue}J.push(_);continue}if(K.type==="punctuation")switch(K.value){case":":case",":{const _=Y0(Q,!1);if(J.length===0)m.push({message:`Left-hand side of ${K.value===","?"commutator":"conjugate"} cannot be empty.`,pos:X,line:q,col:H});else if(_.moveNodes.length===0)return m.push({message:`Right-hand side of ${K.value===","?"commutator":"conjugate"} cannot be empty.`,pos:X,line:q,col:H}),new I(J);J=[new(K.value===","?e:Q0)(new I(J),_)];break}case"(":case"[":{const _=Y0(Q,!1,!0);if(_.isGrouping=!0,_)J.push(_);const $=Q.next();if(!$){m.push({message:`Missing closing ${K.value==="("?"parentheses":"brackets"}`,pos:X,line:q,col:H});break}if($.type!=="punctuation"||K.value==="("&&$.value!==")"||K.value==="["&&$.value!=="]")m.push({message:`Unexpected token '${K.value}'`,pos:X,line:q,col:H});break}case")":case"]":if(Z)m.push({message:`Unexpected closing bracked: '${K.value}'`,pos:X,line:q,col:H});return Q.prev(),new I(J,W?K.amount:1);default:m.push({message:`Bug: Unknown punctuation '${K.value}'`,pos:X,line:q,col:H})}}return new I(J)};function l0(Q){const Z=new j0(Q.filter((W)=>W.type!=="blockComment"&&W.type!=="lineComment"&&W.type!=="whitespace"));return L0.clear(),m.length=0,Y0(Z,!0)}function A0(Q){const Z=new Z0(Q),W=[];while(!0){const J=Z.readNext();if(J===null)break;W.push(J)}return[l0(W),m.slice()]}class j0{#Q;#Z;constructor(Q){this.#Q=Q,this.#Z=0}next(){return this.#Q[this.#Z++]??null}prev(){this.#Z--}current(){return this.#Q[this.#Z-1]??null}peek(){return this.#Q[this.#Z]??null}peekRelevant(){for(let Q=this.#Z;Q<this.#Q.length;Q++){switch(this.#Q[Q].type){case"blockComment":case"lineComment":case"whitespace":continue}return this.#Q[Q]}return null}}var L0=new Map,m=[];class I{type="Alg";nodes;moveNodes;length;isGrouping;amount;constructor(Q,Z=1,W=!1){this.nodes=Q,this.moveNodes=[],this.amount=Z,this.isGrouping=W,this.length=0;for(let J of Q)switch(J.type){case"Alg":case"Move":case"Commutator":case"Conjugate":this.moveNodes.push(J),this.length+=J.length;break}}static fromString(Q){const[Z,W]=A0(Q);if(W.length>0){let J="";for(let K of W)J+=`Error Ln ${K.line} Col ${K.col}: ${K.message}\n`;throw new Error(J)}return Z}copy(){const Q=[];for(let Z of this.nodes)Q.push(Z.copy());return new I(Q,this.amount,this.isGrouping)}expanded(){if(this.amount===0)return[];const Q=[];for(let W of this.nodes){if(W.type==="Whitespace"||W.type==="Comment"){Q.push(W);continue}Q.push(...W.expanded())}if(this.amount<0){Q.reverse();for(let W of Q)if(W.type==="Move")W.invert()}const Z=Q.length;v(Q,Math.abs(this.amount));for(let W=Z;W<Q.length;W++)Q[W]=Q[W].copy();return Q}expandedMoves(){if(this.amount===0)return[];const Q=[];for(let W of this.nodes){if(W.type==="Whitespace"||W.type==="Comment")continue;Q.push(...W.expandedMoves())}if(this.amount<0)Q.reverse(),Q.forEach((W)=>W.invert());const Z=Q.length;v(Q,Math.abs(this.amount));for(let W=Z;W<Q.length;W++)Q[W]=Q[W].copy();return Q}invert(){for(let Q of this.moveNodes)Q.invert();return this.nodes.reverse(),this}toString(){let Q="";for(let Z of this.nodes)Q+=Z.toString();if(this.isGrouping){const Z=Math.abs(this.amount);if(Z!==1)Q+=Z.toString();if(this.amount<0)Q+="'";return`(${Q})`}return Q}simplify(){let Q=!0;while(Q){Q=!1;let Z=null,W=-1;for(let J=0;J<this.nodes.length;J++){let K=this.nodes[J];if(K.type==="Whitespace"||K.type==="Comment")continue;if(K.simplify(),K.type==="Move"){if(K.amount===0){this.nodes.splice(J,1),J--;continue}}if(K.type==="Move"&&Z?.type==="Move"){if(K.face===Z.face){Q=!0,Z.amount+=K.amount,this.nodes.splice(J,1),J=W;continue}}Z=K,W=J}}return this}forward(){return{[Symbol.iterator]:()=>new f(this)}}reverse(){return{[Symbol.iterator]:()=>new f(this,!0)}}[Symbol.iterator](){return new f(this)}}class H0{type="Comment";value;commentType;constructor(Q,Z){this.value=Q,this.commentType=Z}copy(){return new H0(this.value,this.commentType)}toString(){if(this.commentType==="lineComment")return`//${this.value}`;return`/*${this.value}*/`}}class G0{type="Whitespace";value;constructor(Q){this.value=Q}copy(){return new G0(this.value)}toString(){return this.value}}var M0=function(Q){switch(Q){case G.U:return G.D;case G.F:return G.B;case G.R:return G.L;case G.B:return G.F;case G.L:return G.R;case G.D:return G.U;default:return G.U}},E0=function(Q){switch(Q){case G.U:return"U";case G.F:return"F";case G.R:return"R";case G.B:return"B";case G.L:return"L";case G.D:return"D";default:return"?"}},W0=function(Q){switch(Q.toUpperCase()){case"U":return G.U;case"F":return G.F;case"R":return G.R;case"B":return G.B;case"L":return G.L;case"D":return G.D;default:return-1}},i=function(Q,Z){let W=Q%Z,J=Math.floor(Q/Z),K=Z-J-1;return W*Z+K},c0=function(Q,Z){let W=Q%Z,K=Math.floor(Q/Z);return(Z-W-1)*Z+K},G;(function(q){q[q["U"]=0]="U";q[q["L"]=1]="L";q[q["F"]=2]="F";q[q["R"]=3]="R";q[q["B"]=4]="B";q[q["D"]=5]="D"})(G||(G={}));class B{#Q;stickers;constructor(Q){console.assert(Number.isInteger(Q)&&Q>1),this.#Q=Q;let Z=Q*Q;this.stickers=Array(6);for(let W=0;W<6;W++){this.stickers[W]=Array(Z);for(let J=0;J<Z;J++)this.stickers[W][J]=W}}static fromString(Q){const Z=Math.floor(Math.sqrt(Q.length/6)),W=Z*Z,J=new B(Z);for(let K=0;K<6;K++)for(let X=0;X<W;X++)J.stickers[K][X]=W0(Q[K*W+X]);return J}toString(){const Q=[],Z=this.#Q*this.#Q;for(let W=0;W<6;W++)for(let J=0;J<Z;J++)Q.push(E0(this.stickers[W][J]));return Q.join("")}getLayerCount(){return this.#Q}solve(){let Q=this.#Q*this.#Q;for(let Z=0;Z<6;Z++)for(let W=0;W<Q;W++)this.stickers[Z][W]=Z}solved(){let Q=this.#Q*this.#Q;for(let Z=0;Z<6;Z++){let W=this.stickers[Z][0];for(let J=1;J<Q;J++)if(this.stickers[Z][J]!==W)return!1}return!0}static#Z(Q,Z,W,J,K,X){W=W.filter((O)=>O!==K(O,!1)&&J(O)!==J(Z));const q=(O,L)=>{return J(O)===J(L)},H=Array(Q).fill(!1),_=[];let $=K(Z,!1),k=Z;H[J(Z)]=!0;let T=0;Q:while(!0){if(T++>100)return console.error("Infinite loop error"),_;if(q($,k)||q($,Z)){if(q($,k)&&!q($,Z)){if(H[J(k)]=!0,_.push($),X)X($)}while(!0){const O=W.shift();if(O===void 0)break Q;if(!H[J(O)]){k=O;break}}if($=k,_.push($),X)X($);$=K($,!1);continue}if(_.push($),H[J($)]=!0,X)X($);$=K($,!0)}return _}memoEdges(Q,Z){const W=this.#J(),J=(X)=>{return Math.floor(X/2)},K=(X)=>{const q=W[J(X)];return q-q%2+(q+X)%2};return B.#Z(W.length,Q,Z,J,K)}static#W(Q){switch(Q.reduce((W,J)=>W|1<<J,0)){case 17:return 0;case 9:return 1;case 5:return 2;case 3:return 3;case 12:return 4;case 6:return 5;case 18:return 6;case 24:return 7;case 36:return 8;case 40:return 9;case 48:return 10;case 34:return 11;default:throw new Error(`Invalid edge: [${Q.join(", ")}]`)}}#J(){const Q=this.#U(Math.floor(this.#Q/2)),Z=Array(Q.length);for(let W=0;W<Q.length;W++){const J=Q[W];let K;if(J.some((q)=>q===G.U||q===G.D))K=!(J[0]===G.U||J[0]===G.D);else K=!(J[0]===G.F||J[0]===G.B);const X=B.#W(J);Z[W]=X*2+Number(K)}return Z}memoWings(Q,Z,W){const J=this.#X(Q),K=(q)=>q,X=(q)=>J[q];return B.#Z(J.length,Z,W,K,X)}static#K(Q){switch(1<<Q[0]|1<<Q[1]+6){case 1025:return 0;case 80:return 1;case 513:return 2;case 72:return 3;case 257:return 4;case 68:return 5;case 129:return 6;case 66:return 7;case 516:return 8;case 264:return 9;case 132:return 10;case 258:return 11;case 144:return 12;case 1026:return 13;case 528:return 14;case 1032:return 15;case 288:return 16;case 2052:return 17;case 544:return 18;case 2056:return 19;case 1056:return 20;case 2064:return 21;case 160:return 22;case 2050:return 23;default:throw new Error(`Invalid wing: [${Q.join(", ")}]`)}}#X(Q){const Z=this.#_(Q),W=Array(Z.length);for(let J=0;J<Z.length;J++){const K=Z[J];if(J%2===1){const X=K[0];K[0]=K[1],K[1]=X}W[J]=B.#K(K)}return W}memoCorners(Q,Z){const W=this.#q(),J=(X)=>{return Math.floor(X/3)},K=(X)=>{const q=W[J(X)];return q-q%3+(q+X)%3};return B.#Z(W.length,Q,Z,J,K)}static#G(Q){switch(Q.reduce((W,J)=>W|1<<J,0)){case 19:return 0;case 25:return 1;case 13:return 2;case 7:return 3;case 38:return 4;case 44:return 5;case 56:return 6;case 50:return 7;default:throw`Invalid corner: [${Q.join(", ")}]`}}#q(){const Q=this.#V(),Z=Array(Q.length);for(let W=0;W<Q.length;W++){const J=Q[W];if(W%2===1){const H=J[1];J[1]=J[2],J[2]=H}let K=J.findIndex((H)=>H===G.U||H===G.D);if(K===-1)throw new Error(`Invalid corner triplet: [${J.join(", ")}]`);let q=B.#G(J)*3+K;Z[W]=q}return Z}memoCenters(Q,Z,W){const J=this.#Y(Q),K=J.slice(),X=(T)=>Math.floor(T/4),q=(T)=>T,H=(T,O)=>{if(!O)return J[T];const D=X(J[T])*4;for(let C=0;C<4;C++){const x=D+C;if(K[x]===x)continue;const b=J.indexOf(x);y(b!==-1),y(X(J[b])===X(J[T]));const u=J[b];J[b]=J[T],J[T]=u;{const K0=K[b];K[b]=K[T],K[T]=K0}const g="ABCDEFGHIJKLMNOPQRSTUVWX";return console.log(`swap ${g[b]} ${g[T]} (${g[J[b]]} ${g[J[T]]})`),u}return J[T]},$=(T)=>{const O=K[Z];K[Z]=K[T],K[T]=O},k=B.#Z(J.length,Z,W,q,H,$);return console.log(K.map((T)=>"ABCDEFGHIJKLMNOPQRSTUVWX"[T]).join(" ")),k}#Y(Q){const Z=this.#H(Q),W=Array(Z.length),J=Array(Z.length).fill(!1);for(let K=0;K<Z.length;K++){const X=Z[K],q=Math.floor(K/4);if(X===q)W[K]=K,J[K]=!0}for(let K=0;K<Z.length;K++){if(W[K]!==void 0)continue;for(let X=0;X<4;X++){let q=Z[K]*4+X;if(!J[q]){J[q]=!0,W[K]=q;break}}}return y(J.every((K)=>K===!0)),W}#H(Q){const Z=[];for(let W=0;W<6;W++)for(let J=0;J<4;J++)Z.push(this.stickers[W][Q]),Q=i(Q,this.#Q);return Z}#U(Q){const Z=[],W=[G.U,G.L,G.F,G.R,G.B,G.D];for(let $ of W)for(let k=0;k<4;k++)Z.push(this.stickers[$][Q]),Q=i(Q,this.#Q);const J=Z.slice(0,4),K=Z.slice(4,8),X=Z.slice(8,12),q=Z.slice(12,16),H=Z.slice(16,20),_=Z.slice(20,24);return[[J[0],H[0]],[J[1],q[0]],[J[2],X[0]],[J[3],K[0]],[X[1],q[3]],[X[3],K[1]],[H[1],K[3]],[H[3],q[1]],[_[0],X[2]],[_[1],q[2]],[_[2],H[2]],[_[3],K[2]]]}#_(Q){const Z=[];let W=this.#Q-Q-1;const J=[G.U,G.L,G.F,G.R,G.B,G.D];for(let k of J)for(let T=0;T<4;T++)Z.push(this.stickers[k][Q]),Z.push(this.stickers[k][W]),Q=i(Q,this.#Q),W=i(W,this.#Q);const K=Z.slice(0,8),X=Z.slice(8,16),q=Z.slice(16,24),H=Z.slice(24,32),_=Z.slice(32,40),$=Z.slice(40,48);return[[K[0],_[1]],[K[1],_[0]],[K[2],H[1]],[K[3],H[0]],[K[4],q[1]],[K[5],q[0]],[K[6],X[1]],[K[7],X[0]],[q[2],H[7]],[q[3],H[6]],[q[6],X[3]],[q[7],X[2]],[_[2],X[7]],[_[3],X[6]],[_[6],H[3]],[_[7],H[2]],[$[0],q[5]],[$[1],q[4]],[$[2],H[5]],[$[3],H[4]],[$[4],_[5]],[$[5],_[4]],[$[6],X[5]],[$[7],X[4]]]}#V(){const Q=[],Z=[G.U,G.L,G.F,G.R,G.B,G.D];let W=0;for(let $ of Z)for(let k=0;k<4;k++)Q.push(this.stickers[$][W]),W=i(W,this.#Q);const J=Q.slice(0,4),K=Q.slice(4,8),X=Q.slice(8,12),q=Q.slice(12,16),H=Q.slice(16,20),_=Q.slice(20,24);return[[J[0],H[1],K[0]],[J[1],H[0],q[1]],[J[2],X[1],q[0]],[J[3],X[0],K[1]],[_[0],X[3],K[2]],[_[1],X[2],q[3]],[_[2],H[3],q[2]],[_[3],H[2],K[3]]]}#$(Q){const Z=[];for(let J of this.stickers[Q]){const K=document.createElement("div");K.classList.add("sticker"),K.classList.add(E0(J)),Z.push(K)}const W=document.createElement("div");return W.classList.add("face"),W.replaceChildren(...Z),W}#O(){const Q=document.createElement("div");return Q.classList.add("face"),Q}html(Q){Q.classList.add("cube"),Q.style.setProperty("--layer-count",this.#Q.toString()),Q.replaceChildren(this.#O(),this.#$(G.U),this.#O(),this.#O(),this.#$(G.L),this.#$(G.F),this.#$(G.R),this.#$(G.B),this.#O(),this.#$(G.D))}static#k(Q){var Z;(function(H){H[H["U"]=G.U]="U";H[H["R"]=G.R]="R";H[H["L"]=G.L]="L";H[H["D"]=G.D]="D"})(Z||(Z={}));const W=(J,K)=>({face:J,direction:K});switch(Q){case G.U:return[W(G.B,Z.U),W(G.R,Z.U),W(G.F,Z.U),W(G.L,Z.U)];case G.L:return[W(G.U,Z.L),W(G.F,Z.L),W(G.D,Z.L),W(G.B,Z.R)];case G.F:return[W(G.U,Z.D),W(G.R,Z.L),W(G.D,Z.U),W(G.L,Z.R)];case G.R:return[W(G.U,Z.R),W(G.B,Z.L),W(G.D,Z.R),W(G.F,Z.R)];case G.B:return[W(G.U,Z.U),W(G.L,Z.L),W(G.D,Z.D),W(G.R,Z.R)];case G.D:return[W(G.F,Z.D),W(G.R,Z.D),W(G.B,Z.D),W(G.L,Z.D)];default:return console.error(`Invalid face: ${Q}`),[]}}#z(Q){let Z=this.stickers[Q],W=Z.slice();for(let J=0;J<Z.length;J++)Z[J]=W[c0(J,this.#Q)]}#j(Q){let Z=this.stickers[Q],W=Z.slice();for(let J=0;J<Z.length;J++)Z[J]=W[i(J,this.#Q)]}#T(Q,Z){if(Z)this.#j(Q);else this.#z(Q)}#L(Q,Z){const W=[];switch(Q){case G.U:{let J=Z*this.#Q;for(let K=0;K<this.#Q;K++)W.push(J+K);return W}case G.R:{let J=this.#Q-Z-1;for(let K=0;K<this.#Q;K++)W.push(J+this.#Q*K);return W}case G.L:{let J=Z;for(let K=this.#Q-1;K>=0;K--)W.push(J+this.#Q*K);return W}case G.D:{let J=(this.#Q-Z)*this.#Q-this.#Q;for(let K=this.#Q-1;K>=0;K--)W.push(J+K);return W}default:return console.error(`Invalid direction: ${Q}`),[]}}#P(Q,Z){const W=B.#k(Q),J=[];for(let X of W)J.push(this.#L(X.direction,Z));let K=[];for(let X of J[0])K[X]=this.stickers[W[0].face][X];for(let X=0;X<J.length;X++){const q=this.stickers?.[W[X+1]?.face]??K;for(let H=0;H<J[0].length;H++){const _=J[X][H],$=J[(X+1)%J.length][H];if(!Number.isInteger(q[$])){console.error(`Invalid index: ${$}`);continue}this.stickers[W[X].face][_]=q[$]}}}#R(Q,Z){for(let W=0;W<3;W++)this.#P(Q,Z)}#A(Q,Z,W){if(W)this.#P(Q,Z);else this.#R(Q,Z)}reset(){for(let Q=0;Q<6;Q++)for(let Z=0;Z<this.stickers[Q].length;Z++)this.stickers[Q][Z]=Q}move(Q,Z,W=1,J=1){let K=Z<0;if(Z=Math.abs(Z)%4,Z===0)return;K=Z===3!==K;let X=Z===2;if(W=Math.min(W,this.#Q),J=Math.min(J,this.#Q),!X){if(W===1)this.#T(Q,K);if(J>=this.#Q)this.#T(M0(Q),!K);for(let q=W-1;q<J;q++)this.#A(Q,q,K)}else{if(W===1)this.#z(Q),this.#z(Q);if(J>=this.#Q){let q=M0(Q);this.#z(q),this.#z(q)}for(let q=W-1;q<J;q++)this.#R(Q,q),this.#R(Q,q)}}execute(Q){for(let Z of Q)if("UFRBLD".indexOf(Z.face)>-1)this.move(W0(Z.face),Z.amount,Z.shallow,Z.deep);else if("MES".indexOf(Z.face)>-1){if(this.#Q%2===0)continue;let W=W0("LDF"["MES".indexOf(Z.face)]),J=(this.#Q-1)/2+1;this.move(W,Z.amount,J,J)}else if("mes".indexOf(Z.face)>-1){let W=W0("LDF"["mes".indexOf(Z.face)]);this.move(W,Z.amount,2,this.#Q-1)}else if("xyz".indexOf(Z.face)>-1){let W=W0("RUF"["xyz".indexOf(Z.face)]);this.move(W,Z.amount,1,this.#Q)}else console.error(`Move ${Z.face} not supported.`)}executeUntil(Q,Z){for(let W of Q){if(Z--<=0)return W;this.execute(W)}return null}}class w{layerCount;cube;stickersPerFace;#Q;#Z;constructor(Q){this.layerCount=Q,this.cube=new B(Q),this.stickersPerFace=Q**2,this.#Q=new B(Q),this.#Z=new WeakMap}static#W(Q,Z,W){const J=Q.stickers[Z[0][0]][Z[0][1]];for(let K=0;K<Z.length;K++){const X=Z[K],q=s(K+W,Z.length),H=q===0?J:Q.stickers[Z[q][0]][Z[q][1]];Q.stickers[X[0]][X[1]]=H}}static#J(Q,Z,W){const J=Z[Z.length-1],K=Q.stickers[J[0]][J[1]];for(let X=Z.length-1;X>=0;X--){const q=Z[X],H=s(X+W,Z.length),_=H===Z.length-1?K:Q.stickers[Z[H][0]][Z[H][1]];Q.stickers[q[0]][q[1]]=_}}static#K(Q,Z,W){if(W===0)return;if(W>0)for(let J of Z)this.#W(Q,J,W);else for(let J of Z)this.#J(Q,J,W)}#X(Q,Z){return Q*this.stickersPerFace+Z}#G(Q,Z){const W=[];let J=Q,K=Z;do{W.push([J,K]);const X=this.#Q.stickers[J][K];J=Math.floor(X/this.stickersPerFace),K=X%this.stickersPerFace}while(J!==Q||K!==Z);return W}#q(){const Q=[],Z=new Set;for(let W=0;W<6;W++)for(let J=0;J<this.stickersPerFace;J++){const K=this.#X(W,J);if(Z.has(K))continue;if(this.#Q.stickers[W][J]!==K){const X=this.#G(W,J);for(let q=1;q<X.length;q++)Z.add(this.#X(X[q][0],X[q][1]));Q.push(X)}}return Q}#Y(){for(let Q=0;Q<6;Q++)for(let Z=0;Z<this.stickersPerFace;Z++)this.#Q.stickers[Q][Z]=this.#X(Q,Z)}recordAlg(Q){this.#Y();let Z=Q.amount;Q.amount=1,this.#Q.execute(Q),Q.amount=Z;const W=this.#q();return this.#Z.set(Q,W),W}#H(Q){if(this.#Z.has(Q))return;this.#Y();for(let Z of Q.moveNodes)switch(Z.type){case"Alg":this.#H(Z);break;case"Commutator":case"Conjugate":this.#H(Z.algA),this.#H(Z.algB);case"Move":continue;default:throw new Error(`Unimplemented alg move node type in CacheCube.execute(): '${Z.type}'`)}this.#Y();for(let Z of Q.moveNodes)switch(Z.type){case"Alg":{const W=this.#Z.get(Z);y(W!==void 0),w.#K(this.#Q,W,Z.amount);break}case"Commutator":case"Conjugate":{const W=this.#Z.get(Z.algA),J=this.#Z.get(Z.algB);y(W!==void 0&&J!==void 0);const K=Math.abs(Z.amount);if(Z.amount>0){if(w.#K(this.#Q,W,K*Z.algA.amount),w.#K(this.#Q,J,K*Z.algB.amount),w.#K(this.#Q,W,-K*Z.algA.amount),Z.type==="Commutator")w.#K(this.#Q,J,-K*Z.algB.amount)}else{if(Z.type==="Commutator")w.#K(this.#Q,J,K*Z.algB.amount);w.#K(this.#Q,W,K*Z.algA.amount),w.#K(this.#Q,J,-K*Z.algB.amount),w.#K(this.#Q,W,-K*Z.algA.amount)}break}case"Move":this.#Q.execute(Z)}this.#Z.set(Q,this.#q())}execute(Q){let Z=this.#Z.get(Q);if(Z){w.#K(this.cube,Z,Q.amount);return}this.#H(Q),Z=this.#Z.get(Q),y(Z!==void 0),w.#K(this.cube,Z,Q.amount)}}var d0=await navigator.gpu?.requestAdapter(),s0=await d0?.requestDevice(),M=s0;function F0(Q,Z){Z??=new Float32Array(16);for(let W=0;W<4;W++)for(let J=0;J<4;J++)Z[W*4+J]=Q[J*4+W];return Z}function J0(Q,Z,W){W??=new Float32Array(16);for(let J=0;J<4;J++)for(let K=0;K<4;K++){const X=J*4+K;W[X]=0;for(let q=0;q<4;q++)W[X]+=Q[J*4+q]*Z[q*4+K]}return W}function B0(Q){return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,Q[0],Q[1],Q[2],1])}function D0(Q,Z){Z??=new Float32Array(16);const W=Math.cos(Q),J=Math.sin(Q);return Z.set([1,0,0,0,0,W,-J,0,0,J,W,0,0,0,0,1]),Z}function N0(Q,Z){Z??=new Float32Array(16);const W=Math.cos(Q),J=Math.sin(Q);return Z.set([W,0,J,0,0,1,0,0,-J,0,W,0,0,0,0,1]),Z}function f0(Q){return new Float32Array([Q[0],0,0,0,0,Q[1],0,0,0,0,Q[2],0,0,0,0,1])}function I0(Q,Z,W){return new Float32Array([Q/Z,0,0,0,0,Q,0,0,0,0,-1,-2*W,0,0,-1,0])}class A{layerCount;#Q;#Z;#W;#J;#K;#X;#G;#q;#Y;#H;#U=1;#_;constructor(Q,Z){this.layerCount=Z,this.#Q=Q;let W;[this.#Z,W]=A.#$(Q),this.#W=A.#O(Q.width,Q.height),this.#J=A.#k(this.#W),this.#K=A.#z(Z);const J=A.#j(),K=A.#T(J);this.#X=A.#L(this.#K,K,W,this.#W.format),this.#G=A.#P(this.#K,K),this.#q=A.#A(Z),this.#Y=A.#M(),this.#H=A.#E(),this.#_=A.#F(J,this.#Y,this.#q,this.#H),this.reset(),this.clearAnimation()}render(){const Q=M.createCommandEncoder({label:"Draw NxN"});this.#J.colorAttachments[0].view=this.#Z.getCurrentTexture().createView();const Z=Q.beginRenderPass(this.#J);Z.setPipeline(this.#X);for(let W=0;W<this.#_.length;W++)Z.setBindGroup(W,this.#_[W]);Z.draw(4,6*this.#U),Z.end(),M.queue.submit([Q.finish()])}reset(){const Q=M.createCommandEncoder({label:"Reset NxN"}),Z=Q.beginComputePass();Z.setPipeline(this.#G);for(let W=0;W<this.#_.length;W++)Z.setBindGroup(W,this.#_[W]);Z.dispatchWorkgroups(Math.ceil(this.#q.size/256)),Z.end(),M.queue.submit([Q.finish()])}setCameraTransform(Q,Z,W){const J=J0(f0(Array(3).fill(0.8)),J0(J0(N0(W),D0(Z)),B0(Q))),K=I0(2,this.#Q.width/this.#Q.height,0.01),X=new Float32Array(16);X.set(J0(J,F0(K))),M.queue.writeBuffer(this.#Y,0,X)}set(Q){const Z=new ArrayBuffer(this.#q.size),W=new Uint32Array(Z);let J=0,K=0;for(let X=0;X<Q.stickers.length;X++)for(let q=0;q<Q.stickers[X].length;q++)if(W[J]|=Q.stickers[X][q]<<K,K+=3,K>=30)J++,K=0;M.queue.writeBuffer(this.#q,0,Z)}static#V(Q,Z,W,J){if(Z<=0)return[];return[Q|Z<<16,W|J<<16]}animateMove(Q,Z){function W(q,H){return(q%H+H)%H}const J="ULFRBD".indexOf(Q.face.toUpperCase());if(J===-1)throw new Error(`Unsupported face '${Q.face}'`);const K=[],X=W(Math.floor(65535*Z*Q.amount/4),65535);if(Q.shallow===1)K.push(...A.#V(X,Q.deep,this.layerCount-Q.deep,J)),K.push(...A.#V(0,this.layerCount-Q.deep,0,J));else K.push(...A.#V(0,Q.shallow-1,this.layerCount-Q.shallow+1,J)),K.push(...A.#V(X,Q.deep-Q.shallow+1,this.layerCount-Q.deep,J)),K.push(...A.#V(0,this.layerCount-Q.deep,0,J));this.#U=K.length/2,M.queue.writeBuffer(this.#H,0,new Uint32Array(K))}clearAnimation(){const Q=new Uint32Array(A.#V(0,this.layerCount,0,0));this.#U=1,M.queue.writeBuffer(this.#H,0,new Uint32Array(Q))}destroy(){this.#Z.unconfigure(),this.#W.destroy(),this.#q.destroy(),this.#Y.destroy()}resize(Q,Z){if(this.#Q.width===Q&&this.#Q.height===Z)return;this.#Q.width=Q,this.#Q.height=Z,this.#W.destroy(),this.#W=A.#O(Q,Z);const W=this.#J.depthStencilAttachment;W.view=this.#W.createView()}static#$(Q){y(Q.width!==0&&Q.height!==0);const Z=Q.getContext("webgpu");if(!Z)throw new Error("Failed to initialize WebGPU canvas context");const W=navigator.gpu.getPreferredCanvasFormat();return Z.configure({device:M,format:W}),[Z,W]}static#O(Q,Z){return M.createTexture({size:{width:Q,height:Z},format:"depth16unorm",dimension:"2d",usage:GPUTextureUsage.RENDER_ATTACHMENT})}static#k(Q){return{label:"Draw NxN Render Pass Descriptor",colorAttachments:[{view:null,clearValue:[1,1,1,1],loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:Q.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}}}static#z(Q){const Z=A.#R(Q)/4,W=`
            struct CameraData {
                viewProjMatrix: mat4x4f,
            };

            struct BlockData {
                packedRotationScale: u32,
                packedAxisTranslation: u32,
            };

            const vertices = array<vec2f, 4>(
                vec2f(-1.0, -1.0),
                vec2f(-1.0,  1.0),
                vec2f( 1.0, -1.0),
                vec2f( 1.0,  1.0),
            );
            const normals = array<vec3f, 6>(
                vec3f( 0.0,  1.0,  0.0),
                vec3f(-1.0,  0.0,  0.0),
                vec3f( 0.0,  0.0,  1.0),
                vec3f( 1.0,  0.0,  0.0),
                vec3f( 0.0,  0.0, -1.0),
                vec3f( 0.0, -1.0,  0.0)
            );
            const colors = array<vec4f, 8>(
                vec4f(1.0, 1.0, 1.0, 1.0),
                vec4f(1.0, 0.6, 0.0, 1.0),
                vec4f(0.0, 1.0, 0.0, 1.0),
                vec4f(1.0, 0.0, 0.0, 1.0),
                vec4f(0.0, 0.0, 1.0, 1.0),
                vec4f(1.0, 1.0, 0.0, 1.0),
                // unused
                vec4f(0.0, 0.0, 0.0, 1.0),
                vec4f(0.0, 0.0, 0.0, 1.0),
            );
        
            @group(0) @binding(0) var<uniform> cameraData: CameraData;
            @group(0) @binding(1) var<storage, read_write> stickers: array<u32, ${Z}>;
            @group(0) @binding(2) var<storage, read> blocks: array<BlockData>;
        
            struct VertexOut {
                @builtin(position) position: vec4f,
                @location(0) uv: vec2f,
                @location(1) @interpolate(flat) face: u32,
                @location(2) @interpolate(flat) fill: u32,
            };
    
            @vertex
            fn vert_main(@builtin(vertex_index) vertexId: u32, @builtin(instance_index) instanceId: u32) -> VertexOut {
                var out: VertexOut;

                var vertex = vertices[vertexId];
                let normal = normals[instanceId % 6];

                let block = blocks[instanceId / 6];

                let scaleU32 = (block.packedRotationScale >> 16) & 0xffff;
                let translationU32 = block.packedAxisTranslation & 0xffff;

                let rotation: f32 = -f32(block.packedRotationScale & 0xffff) / f32(0xffff) * 6.2831853072;
                let halfScale: f32 = f32(scaleU32) / f32(${Q});
                let translation: f32 = -1 + 2 * f32(translationU32) / f32(${Q});
                let axis: vec3f = normals[(block.packedAxisTranslation >> 16) & 0x7];

                var position = vec3f(vertex, 0.0);
                if (normal.x != 0) { position = position.zxy + normal; }
                if (normal.y != 0) { position = position.xzy + normal; }
                if (normal.z != 0) { position += normal; }

                let normalDotAxis = dot(normal, axis);
                out.fill = u32(
                    (normalDotAxis == 1.0 && translationU32 + scaleU32 < ${Q}) ||
                    (normalDotAxis == -1.0 && translationU32 != 0)
                );

                if (normalDotAxis > 0.1) {
                    position -= position * abs(axis);
                    position += axis * (translation + halfScale * 2);
                } else if (normalDotAxis < -0.1) {
                    position -= position * abs(axis);
                    position += axis * translation;
                } else {
                    let positionDotAxis = dot(position, axis);
                    if (positionDotAxis > 0.1) {
                        position -= position * abs(axis);
                        position += axis * (translation + halfScale * 2);
                    } else {
                        position -= position * abs(axis);
                        position += axis * translation;
                    }

                    let scale = halfScale * 2.0;

                    if (axis.x != 0.0) {
                        vertex.x *= halfScale;
                        vertex.x += axis.x * (halfScale + translation);
                    } else if (axis.y != 0.0) {
                        let i = instanceId % 6;
                        if (i == 1 || i == 3) {
                            vertex.x *= halfScale;
                            vertex.x += axis.y * (halfScale + translation);
                        } else {
                            vertex.y *= halfScale;
                            vertex.y += axis.y * (halfScale + translation);
                        }
                    } else if (axis.z != 0.0) {
                        vertex.y *= halfScale;
                        vertex.y += axis.z * (halfScale + translation);
                    }
                }

                // https://en.wikipedia.org/wiki/Axis-angle_representation#Rotating_a_vector
                position =
                    cos(rotation) * position +
                    sin(rotation) * cross(axis, position) +
                    (1 - cos(rotation)) * dot(axis, position) * axis;

                out.position = cameraData.viewProjMatrix * vec4f(position * 0.1, 1);
                out.uv = vertex;
                out.face = instanceId % 6;

                switch (instanceId % 6) {
                    case 1: { out.uv = vec2f(out.uv.y, -out.uv.x); break; }
                    case 2: { out.uv.y *= -1; break; }
                    case 3: { out.uv = vec2f(-out.uv.y, -out.uv.x); break; }
                    case 4: { out.uv *= -1; break; }
                    case 5: { out.uv.y *= -1; break; }
                    default: { break; }
                }

                out.uv = (out.uv + 1) / 2;
    
                return out;
            }
    
            @fragment
            fn frag_main(in: VertexOut) -> @location(0) vec4f {
                const lineWidth = vec2f(0.1);
                const gridRepeat = vec2f(${Q});

                // https://bgolus.medium.com/the-best-darn-grid-shader-yet-727f9278b9d8
                var gridAA = max(abs(dpdx(in.uv)), abs(dpdy(in.uv))) * 1;

                if (bool(in.fill)) {
                    return vec4f(0, 0, 0, 1);
                }

                var drawWidth = clamp(lineWidth, gridAA, vec2f(0.5));
                var gridUV = 1.0 - abs(fract(in.uv * gridRepeat) * 2.0 - 1.0);
                var grid2 = smoothstep(drawWidth + gridAA, drawWidth - gridAA, gridUV);
                grid2 *= saturate(lineWidth / drawWidth);
                grid2 = mix(grid2, lineWidth, saturate(gridAA * 2.0 - 1.0));
                var grid = max(grid2.x, grid2.y);

                var i2 = vec2u(floor(in.uv * gridRepeat));
                var index =
                    in.face * u32(gridRepeat.x) * u32(gridRepeat.y) +
                    i2.y * u32(gridRepeat.x) + i2.x;
                var colorIndex = (stickers[index / 10] >> ((index % 10) * 3)) & 0x7;

                return mix(colors[colorIndex], vec4f(0, 0, 0, 1), grid);
            }

            @compute @workgroup_size(64) fn initStickers(
                @builtin(global_invocation_id) gid: vec3<u32>
            ) {
                if (gid.x < ${Z}) {
                    let id = gid.x * 10;
                    var value: u32 = 0;
                    for (var i: u32 = 0; i < 10; i++) {
                        value |= ((i + id) / ${Q*Q}) << (i * 3);
                    }
                    stickers[gid.x] = value;
                }
            }
        `;return M.createShaderModule({label:"puzzle shader module",code:W})}static#j(){return M.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}}]})}static#T(Q){return M.createPipelineLayout({bindGroupLayouts:[Q]})}static#L(Q,Z,W,J){return M.createRenderPipeline({label:"Draw Puzzle Render Pipeline",layout:Z,vertex:{module:Q,entryPoint:"vert_main"},fragment:{module:Q,entryPoint:"frag_main",targets:[{format:W}]},depthStencil:{format:J,depthWriteEnabled:!0,depthCompare:"less"},primitive:{topology:"triangle-strip"}})}static#P(Q,Z){return M.createComputePipeline({layout:Z,compute:{module:Q,entryPoint:"initStickers"}})}static#R(Q){return Math.ceil(6*Q*Q/10)*4}static#A(Q){return M.createBuffer({label:"Sticker Buffer",size:A.#R(Q),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST})}static#M(){return M.createBuffer({size:80,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})}static#E(){return M.createBuffer({size:24,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST})}static#F(Q,Z,W,J){return[M.createBindGroup({layout:Q,entries:[{binding:0,resource:{buffer:Z}},{binding:1,resource:{buffer:W}},{binding:2,resource:{buffer:J}}]})]}}var $0;(function(w0){w0.SOLVED_STATE=5517840;const Z=0,W=1,J=2,K=3,X=4,q=5,H=6,_=7;let $;(function(P){P[P["M"]=1]="M";P[P["M2"]=2]="M2";P[P["MPrime"]=3]="MPrime";P[P["U"]=4]="U";P[P["U2"]=5]="U2";P[P["UPrime"]=6]="UPrime"})($||($={}));function k(Y){switch(Y){case $.M:return"M";case $.M2:return"M2";case $.MPrime:return"M'";case $.U:return"U";case $.UPrime:return"U'";case $.U2:return"U2";default:throw new Error(`Invalid LSE move number: '${Y}'`)}}function T(Y){switch(Y){case"M":return $.M;case"M'":return $.MPrime;case"M2":return $.M2;case"U":return $.U;case"U'":return $.UPrime;case"U2":return $.U2;default:throw new Error(`Invalid LSE move: '${Y}'`)}}w0.stringToLseMove=T;function O(Y,U){return Y>>U*4&15}function L(Y,U,V){return Y&(~0^15<<U*4)|V<<U*4}function D(Y,U,V,R,j){let z=Y;return z=L(z,U,O(Y,j)),z=L(z,V,O(Y,U)),z=L(z,R,O(Y,V)),z=L(z,j,O(Y,R)),z}function C(Y,U,V,R,j){let z=Y;return z=L(z,U,O(Y,V)),z=L(z,V,O(Y,R)),z=L(z,R,O(Y,j)),z=L(z,j,O(Y,U)),z}function x(Y,U,V){let R=Y;return R=L(R,U,O(Y,V)),R=L(R,V,O(Y,U)),R}function b(Y){return Y^8914952}function u(Y,U){return L(Y,7,(O(Y,7)+U)%4)}function g(Y,U){return L(Y,6,(O(Y,6)+U)%4)}function K0(Y,U){switch(U){case $.M:Y=C(Y,0,5,4,2),Y=b(Y),Y=u(Y,3);break;case $.MPrime:Y=D(Y,0,5,4,2),Y=b(Y),Y=u(Y,1);break;case $.M2:Y=x(Y,0,4),Y=x(Y,2,5),Y=u(Y,2);break;case $.U:Y=D(Y,0,1,2,3),Y=g(Y,1);break;case $.UPrime:Y=C(Y,0,1,2,3),Y=g(Y,3);break;case $.U2:Y=x(Y,0,2),Y=x(Y,1,3),Y=g(Y,2);break;default:throw new Error(`Invalid move: '${U}'`)}return Y}w0.move=K0;function h0(Y){switch(Y){case $.M:return $.MPrime;case $.MPrime:return $.M;case $.U:return $.UPrime;case $.UPrime:return $.U;default:return Y}}function R0(Y,U,V){return Y&~0<<U*3|V<<U*3}function S0(Y,U){return Y>>U*3&7}function y0(Y){return Math.trunc((34-Math.clz32(Y))/3)}function o0(Y){let U=0;for(let V=0;V<Y.length;V++)U=R0(U,V,Y[V]);return U}function C0(Y){const U=[];for(let V=0;V<10;V++){const R=S0(Y,V);if(R)U.push(R)}return U}const n=new Map;let r=0;function X0(Y,U,V,R){const j=V?1:4,z=V?4:7;for(let P=j;P<z;P++){const E=P,N=K0(Y,E);if(N===5517840)continue;const F=R0(R,U-1,h0(E)),h=n.get(N);if(h===void 0)n.set(N,F);else if(typeof h==="number")n.set(N,[h,F]);else h.push(F);if(U>1)X0(N,U-1,!V,F)}}function i0(){r=10,console.time("fill table"),X0(5517840,r,!0,0),X0(5517840,r,!1,0),console.timeEnd("fill table")}w0.initTable=i0;function b0(){r=0,console.time("clear table"),n.clear(),console.timeEnd("clear table")}w0.clearTable=b0;function a(Y,U,V,R,j,z){let P=n.get(Y);if(P!==void 0){if(typeof P==="number")P=[P];for(let F of P){if(y0(F)>V)continue;z.push(j.concat(C0(F)).map((h)=>k(h)).join(" "))}return}else if(V<=r)return;const E=R?1:4,N=R?4:7;for(let F=E;F<N;F++){const h=F,t=K0(Y,h);if(j.push(h),U(t))z.push(j.map((S)=>k(S)).join(" "));else if(V>1)a(t,U,V-1,!R,j,z);j.pop()}}w0.search=a;function n0(Y,U){const V=[],R=(j)=>j===5517840;return console.time("solve"),a(Y,R,U,!0,[],V),a(Y,R,U,!1,[],V),console.timeEnd("solve"),V}w0.solve=n0;function q0(Y,U,V,R,j,z){let P=0;if(Y)P=L(P,0,8);if(U)P=L(P,1,8);if(V)P=L(P,2,8);if(R)P=L(P,3,8);if(j)P=L(P,4,8);if(z)P=L(P,5,8);return P}function x0(Y){let U=Y;const V=[3,1],R=O(Y,0),j=O(Y,1),z=O(Y,2),P=O(Y,3),E=O(Y,4),N=O(Y,5);if(V.indexOf(R&7)===-1)U=L(U,0,R&8);if(V.indexOf(j&7)===-1)U=L(U,1,j&8);if(V.indexOf(z&7)===-1)U=L(U,2,z&8);if(V.indexOf(P&7)===-1)U=L(U,3,P&8);if(V.indexOf(E&7)===-1)U=L(U,4,E&8);if(V.indexOf(N&7)===-1)U=L(U,5,N&8);return U}const p0=q0(!1,!1,!1,!1,!1,!1),v0=q0(!1,!0,!1,!0,!0,!0),T0=q0(!0,!0,!0,!0,!0,!0);function P0(Y){if(O(Y,7)%2===0){if((Y&T0)!==p0)return!1}else if((Y&T0)!==v0)return!1;const V=O(Y,2),R=O(Y,0);switch(O(Y,6)){case 0:case 2:return!1;case 1:if(V!==1||R!==3)return!1;break;case 3:if(V!==3||R!==1)return!1;break}return!0}function r0(Y,U){const V=[],R=x0(Y),j=document.createElement("div");document.body.appendChild(j),B.fromString(m0(R)).html(j);function P(E){E=Array(32-E.length%32).fill("0").join("")+E;const N=[];for(let F=0;F<E.length;F+=4)N.push(E.slice(F,Math.min(F+4,E.length)));return N.join(" ")}return b0(),a(R,P0,U,!0,[],V),a(R,P0,U,!1,[],V),V}w0.solveEOLR=r0;function m0(Y){const U=O(Y,7),V=["U","B","D","F"];for(let S=0;S<U;S++)V.unshift(V.pop());const R=O(Y,6),j=["F","L","B","R"];for(let S=0;S<R;S++)j.unshift(j.pop());function z(S){const u0=S&8;S&=7;let p;switch(S){case 0:p="UB";break;case 1:p="UR";break;case 2:p="UF";break;case 3:p="UL";break;case 4:p="DF";break;case 5:p="DB";break;default:throw new Error(`Invalid edge nibble: ${S.toString(2)}`)}if(u0)return p[1]+p[0];return p}const P=z(O(Y,0)),E=z(O(Y,1)),N=z(O(Y,2)),F=z(O(Y,3)),h=z(O(Y,4)),t=z(O(Y,5));return`U${P[0]}U${F[0]}${V[0]}${E[0]}U${N[0]}U`+`${j[1]}${F[1]}${j[1]}LLLLLL`+`${j[0]}${N[1]}${j[0]}F${V[3]}FF${h[1]}F`+`${j[3]}${E[1]}${j[3]}RRRRRR`+`${j[2]}${P[1]}${j[2]}B${V[1]}BB${t[1]}B`+`D${h[0]}DD${V[2]}DD${t[0]}D`}w0.stateToString=m0;function g0(Y){let U=0;for(let V=0;V<Y.length;V++)if(Y[V]!==V){const R=Y[Y[V]];Y[Y[V]]=Y[V],Y[V]=R,U++,V--;continue}return U}function a0(){const Y=Math.floor(4*Math.random()),U=Math.floor(4*Math.random()),V=[0,1,2,3,4,5],R=Array(6).fill(0).map(()=>V.splice(Math.floor(V.length*Math.random()),1)[0]),j=Array(6).fill(0).map(()=>Math.floor(2*Math.random()));if(j.reduce((P,E)=>P+E)%2!==0)j[0]^=1;let z=0;if(z=L(z,0,R[0]|j[0]<<3),z=L(z,1,R[1]|j[1]<<3),z=L(z,2,R[2]|j[2]<<3),z=L(z,3,R[3]|j[3]<<3),z=L(z,4,R[4]|j[4]<<3),z=L(z,5,R[5]|j[5]<<3),z=L(z,6,Y),z=L(z,7,U),g0(R)%2!==(Y+U)%2)z=x(z,4,5);return z}w0.getRandomState=a0})($0||($0={}));class _0 extends HTMLElement{#Q;#Z;#W;#J=0;constructor(){super();this.#Q=document.createElement("textarea"),this.#Q.placeholder="Click here to add moves",this.#Q.rows=1,this.#Q.spellcheck=!1,this.#Q.addEventListener("input",()=>{this.#Q.style.height="0px",this.#Q.style.height=this.#Q.scrollHeight+"px",window.cancelAnimationFrame(this.#J),this.#J=window.requestAnimationFrame(()=>{try{const Q=I.fromString(this.#Q.value);this.dispatchEvent(new CustomEvent("alg-parse",{detail:Q})),this.#Q.classList.remove("invalid"),this.#Z.style.display=""}catch(Q){this.#Q.classList.add("invalid"),this.#Z.textContent=Q,this.#Z.style.display="block"}})}),this.#Z=document.createElement("div"),this.#Z.classList.add("error-message"),this.#W=document.createElement("div"),this.#W.classList.add("rows-ruler")}get value(){return this.#Q.value}set value(Q){this.#Q.value=Q,this.#Q.dispatchEvent(new InputEvent("input"))}connectedCallback(){this.appendChild(this.#W),this.appendChild(this.#Q),this.appendChild(this.#Z);const Q="alg-textarea-style";if(!document.querySelector(`style#${Q}`)){const Z=document.createElement("style");Z.id=Q,Z.textContent=`
                alg-textarea textarea, alg-textarea .rows-ruler {
                    position: relative;
                    width: 100%;
                    background-color: #444;
                    box-sizing: border-box;
                    font-family: Arial, Helvetica, sans-serif;
                    font-size: 1.5em;
                    padding: 0.75em;
                    resize: none;
                    line-height: 1.2em;
                    overflow: hidden;
                }
                alg-textarea textarea.invalid {
                    background-color: #933;
                }
                alg-textarea .error-message {
                    position: relative;
                    width: 100%;
                    background-color: #b66;
                    color: white;
                    font-family: Arial, Helvetica, sans-serif;
                    text-align: center;
                    padding: 0.25em;
                    box-sizing: border-box;
                    display: none;
                }
                alg-textarea .rows-ruler {
                    position: absolute;
                    pointer-events: none;
                    white-space: pre-wrap;
                    visibility: hidden;
                }
            `,document.head.appendChild(Z)}}static get observedAttributes(){return["min-rows","value"]}attributeChangedCallback(Q,Z,W){switch(Q){case"min-rows":const J=()=>{let K=Number.parseInt(W);this.#W.textContent=Array(K).fill("\n").join(""),this.#Q.style.minHeight=this.#W.clientHeight+"px"};if(document.readyState!=="complete"){window.addEventListener("load",J);break}J();break;case"value":this.#Q.value=W;break}}}customElements.define("alg-textarea",_0);class U0 extends HTMLElement{#Q;#Z;#W;#J;#K=0;constructor(){super();this.#Q=document.createElement("div"),this.#Q.className="text-input",this.#Q.contentEditable="true",this.#Q.spellcheck=!1,this.#Q.addEventListener("beforeinput",this.#X),this.#Z=document.createElement("div"),this.#Z.className="error-message",this.#W=document.createElement("div"),this.#W.className="placeholder",this.#W.textContent="Click here to add moves",this.#J=document.createElement("div"),this.#J.classList.add("text-input","rows-ruler")}get value(){return this.#Q.textContent??""}set value(Q){this.#Q.textContent=Q,this.#Q.dispatchEvent(new InputEvent("input"))}connectedCallback(){this.appendChild(this.#J),this.appendChild(this.#W),this.appendChild(this.#Q),this.appendChild(this.#Z);const Q="alg-input-style";if(!document.querySelector(`style#${Q}`)){const W=document.createElement("style");W.id=Q,W.textContent=`
                alg-input {
                    background-color: #444;
                    display: block;
                    position: relative;
                }

                alg-input .text-input {
                    position: relative;
                    line-height: 1.2em;
                    width: 100%;
                    box-sizing: border-box;
                    font-family: Arial, Helvetica, sans-serif;
                    font-size: 1.5em;
                    padding: 0.75em;
                    margin: 0;
                    border-radius: 0;
                    color: white;
                    border: 1px solid #777;
                    display: inline-block;
                    white-space: pre-wrap;
                    word-wrap: break-word;
                }

                alg-input .placeholder {
                    position: absolute;
                    line-height: 1.2em;
                    font-size: 1.5em;
                    padding: 0.75em;
                    color: #777;
                    user-select: none;
                    pointer-events: none;
                }

                alg-input .error-message {
                    position: relative;
                    width: 100%;
                    background-color: #b66;
                    color: white;
                    font-family: Arial, Helvetica, sans-serif;
                    text-align: center;
                    padding: 0.25em;
                    box-sizing: border-box;
                    display: none;
                }

                alg-input .rows-ruler {
                    position: absolute;
                    width: 0px;
                    right: 0;
                    opacity: 0;
                }

                .text-input span {
                    background-color: transparent;
                }
                .text-input span.comment {
                    color: #888;
                    font-style: italic;
                }
                .text-input span.move {
                    color: #ddd;
                }
                .text-input span.punctuation {
                    /* color: white; */
                    color: #aaa;
                }
                .text-input span.rotation {
                    /* color: yellow; */
                    color: skyblue;
                }
            `,document.head.appendChild(W)}const Z=document.createElement("link");Z.rel="stylesheet",Z.href="/src/cubing/templates/alg-input.css",this.appendChild(Z)}static get observedAttributes(){return["min-rows"]}attributeChangedCallback(Q,Z,W){switch(Q){case"min-rows":const J=()=>{let K=Number.parseInt(W);this.#J.textContent=Array(K).fill("\n").join(""),this.#Q.style.minHeight=this.#J.clientHeight+"px"};if(document.readyState!=="complete")window.addEventListener("load",J);else J();break}}#X=async(Q)=>{console.time("alg-input.oninput"),Q.preventDefault();const Z=Q.getTargetRanges()[0];if((this.#Q.textContent??"")===""||this.#Q.childNodes.length===1&&this.#Q.firstChild?.textContent==="\n")this.#W.style.display="";else this.#W.style.display="none";try{let{startContainer:J,endContainer:K}=Z,X=document.createRange();X.setStart(J,Z.startOffset),X.setEnd(K,Z.endOffset);let q=window.getSelection(),H=K,_=0;console.assert(q!==null);let $=Q.data??"";switch(Q.inputType){case"insertText":{if(J===this.#Q){let k=J.textContent??"";k=k.slice(0,Z.startOffset)+$+k.slice(Z.startOffset),J.textContent=k,H=J,_=Z.startOffset+$.length}break}case"insertFromPaste":case"deleteWordBackward":case"deleteSoftLineBackward":case"deleteContentBackward":{if(_=Z.startOffset,J!==K){J.textContent=(J.textContent??"").slice(0,Z.startOffset);while(!0){const O=J.nextSibling;if(O===null||O===K)break;O.remove()}K.textContent=(K.textContent??"").slice(0,Z.endOffset),H=K,_=0}else{let O=J.textContent??"";J.textContent=O.slice(0,Z.startOffset)+O.slice(Z.endOffset),_=Z.startOffset}if(Q.inputType!=="insertFromPaste")break;const k=await navigator.clipboard.readText();let T=J.textContent??"";J.textContent=T.slice(0,Z.startOffset)+k+T.slice(Z.startOffset),_+=k.length;break}case"insertParagraph":{let k=!0;for(let T of this.#Q.children)if(T.tagName==="BR"){k=!1;break}if(J===this.#Q){if(console.log(1),k)this.#Q.prepend(document.createElement("br"));this.#Q.prepend(document.createElement("br"))}else if(J===K){console.log(2);let T=J.textContent??"",O=T.slice(0,Z.startOffset),L=T.slice(Z.startOffset);const D=J.cloneNode();if(J.textContent=O,D.textContent=L,this.#Q.insertBefore(D,J.nextSibling),this.#Q.insertBefore(document.createElement("br"),J.nextSibling),k)this.#Q.insertBefore(document.createElement("br"),J.nextSibling)}else{console.log(3);let T=J.textContent??"",O=T.slice(0,Z.startOffset),L=T.slice(Z.startOffset);const D=J.cloneNode(),C=J.parentElement;if(C===null){console.error("Failed to insert paragraph: Node does not have a parent.");break}if(J.textContent=O,D.textContent=L,C.after(D),C.after(document.createElement("br")),k)C.after(document.createElement("br"))}break}default:console.error(`Unknown input type: '${Q.inputType}'`)}q.collapse(H,_),this.#Z.style.display=""}catch(J){this.#Z.textContent=J,this.#Z.style.display="block"}console.timeEnd("alg-input.oninput")};#G(Q){let Z=[],W="",J="";for(let K=0;K<Q.length;K++){const X=Q[K];let q,H;switch(X.type){case"blockComment":case"lineComment":q=X.type==="blockComment"?`/*${X.value}*/`:`//${X.value}`,H="comment";break;case"move":if(X.value.match(/x|y|z/)!==null){q=X.value,H="rotation";break}default:q=X.value,H=X.type;break}if(K===0){if(W=q,H!=="whitespace")J=H;continue}if(H===J||H==="whitespace")W+=q;else{const _=document.createElement("span");_.textContent=W,_.className=J,Z.push(_),W=q,J=H}}if(W!==""){const K=document.createElement("span");K.textContent=W,K.className=J,Z.push(K)}return Z}}customElements.define("alg-input",U0);class V0 extends HTMLElement{multiphase=1;useMilliseconds=!1;inspectionTime=15;timerUpdate=0;triggerKey=" ";#Q=0;set value(Q){this.#Q=Q*1000,this.#Z.textContent=this.display(this.#Q,!1)}display;#Z;constructor(){super();this.#Z=document.createElement("div"),this.appendChild(this.#Z),this.tabIndex=0,this.addEventListener("keydown",(Q)=>{if(Q.key.toLowerCase()===this.triggerKey.toLowerCase())this.#H()}),this.addEventListener("keyup",(Q)=>{if(Q.key.toLowerCase()===this.triggerKey.toLowerCase())this.#_()}),this.display=(Q,Z)=>{if(Z&&Q<=0){if(Q<-2000)return"DNF";return"+2"}const W=Q<0?"-":"";if(Q=Math.floor(Math.abs(Q)),this.timerUpdate!==0)Q-=Q%Math.floor(this.timerUpdate*1000);const J=3600000,K=60000,X=1000,q=Math.floor(Q/J);Q-=q*J;const H=Math.floor(Q/K);Q-=H*K;let _=Math.floor(Q/X);if(Q-=_*X,Z&&Q>0&&W!=="-")_++;let $;if(Z)$="";else $="."+Q.toString().padStart(3,"0").slice(0,this.useMilliseconds?3:2);if(q>0)return`${W}${q}:${H.toString().padStart(2,"0")}:${_.toString().padStart(2,"0")}${$}`;if(H>0)return`${W}${H}:${_.toString().padStart(2,"0")}${$}`;return`${W}${_}${$}`},this.#Z.textContent=this.display(0,!1)}static get observedAttributes(){return["inspection-time","multiphase","timer-update","trigger-key","use-milliseconds","value"]}attributeChangedCallback(Q,Z,W){switch(Q){case"inspection-time":this.inspectionTime=Number(W),this.update();break;case"multiphase":this.multiphase=Number(W);break;case"timer-update":this.timerUpdate=Number(W),this.update();break;case"trigger-key":this.triggerKey=W;break;case"use-milliseconds":this.useMilliseconds=Boolean(W)&&W!=="false"&&W!=="0",this.update();break;case"value":this.value=Number(W);break;default:console.error(`Unknown attribute '${Q}'`)}}#W=0;startInspection(){this.#W=performance.now(),this.#Z.classList.add("inspection"),this.#G=!0,this.update()}#J=0;stopInspection(){this.#J=performance.now()-this.#W,this.#Z.classList.remove("inspection"),this.#G=!1}#K=0;#X=[];start(){this.#K=performance.now(),this.#X.length=0,this.#G=!0,this.update()}stop(){const Q=performance.now()-this.#K;if(this.#X.push(Q),this.#X.length>=this.multiphase){const Z=[];let W=0;for(let K of this.#X)Z.push(Math.floor(K-W)/1000),W=K;const J={time:Math.floor(Q)/1000,phaseTimes:Z,inspectionTime:Math.floor(this.#J)/1000};return this.dispatchEvent(new CustomEvent("timer-stop",{detail:J})),this.#Q=Q,this.#G=!1,!0}return!1}#G=!1;update=()=>{let Q;if(this.#Y)Q=this.inspectionTime*1000-performance.now()+this.#W;else if(this.#q)Q=this.#Q;else Q=performance.now()-this.#K;if(this.#Z.textContent=this.display(Q,this.#Y),this.#G)window.requestAnimationFrame(this.update)};#q=!0;#Y=!1;#H(){if(!this.#q){if(this.stop())this.#U=!0,this.#q=!0}this.#Z.classList.add("down")}#U=!1;#_(){if(this.#q&&!this.#U)if(this.#Y)this.#Y=!1,this.stopInspection(),this.start(),this.#q=!1;else if(this.inspectionTime>0)this.#Y=!0,this.startInspection();else this.start(),this.#q=!1;this.#U=!1,this.#Z.classList.remove("down")}}customElements.define("cube-timer",V0);class O0 extends HTMLElement{cube;alg;ease;#Q;#Z;#W;#J;#K;#X;#G=0;#q=0;#Y=!1;#H=!1;#U=0.001;#_=!1;constructor(){super();this.#Q=document.createElement("input"),this.#Q.type="range",this.#Q.min="0",this.#Q.max="1",this.#Q.step="0.0001",this.#Q.value="1",this.#W=document.createElement("canvas"),this.#Z=document.createElement("button"),this.#Z.textContent="Play",this.#K=this.#W.width,this.#X=this.#W.height,this.cube=new B(3),this.alg=new I([]),this.ease=(Z)=>Z*Z*(3-2*Z),this.#J=new A(this.#W,3),this.#J.reset(),new ResizeObserver(()=>{this.#$()}).observe(this),this.#W.addEventListener("mousemove",(Z)=>{if(this.#Y)this.#G-=Z.movementY*0.005,this.#q-=Z.movementX*0.005,this.#$()}),this.#W.addEventListener("mousedown",()=>{this.#Y=!0}),this.#W.addEventListener("mouseup",()=>{this.#Y=!1}),this.#Q.addEventListener("input",()=>{this.#_=!0,this.#$()}),this.#Z.addEventListener("click",()=>{if(this.#H=!this.#H,this.#Q.value==="1")this.#Q.value="0";this.#$()}),this.#$()}connectedCallback(){const Q=document.createElement("div");Q.className="bottom-wrapper",Q.append(this.#Q,this.#Z),this.append(this.#W,Q);const Z="alg-textarea-style";if(!document.querySelector(`style#${Z}`)){const W=document.createElement("style");W.id=Z,W.textContent=`
                puzzle-viewer {
                    display: flex;
                    flex-direction: column;
                }

                puzzle-viewer .bottom-wrapper {
                    flex-basis: 50px;
                    background-color: black;
                    padding: 10px;
                    box-sizing: border-box;

                    & input[type="range"] {
                        width: 100%;
                    }
                }
                
                puzzle-viewer canvas {
                    flex: 1;
                }
            `,this.appendChild(W)}}static get observedAttributes(){return["size","alg"]}attributeChangedCallback(Q,Z,W){switch(Q){case"size":{const J=Number(W);if(J>0&&Number.isInteger(J)&&J!=this.cube.getLayerCount())this.cube=new B(J),this.#_=!0;break}case"alg":this.alg=I.fromString(W),this.#_=!0;break}this.#$()}update(){if(this.#O(this.#W.clientWidth,this.#W.clientHeight),this.cube.getLayerCount()!=this.#J.layerCount)this.#J.destroy(),this.#J=new A(this.#W,this.cube.getLayerCount());if(this.#_){if(this.cube.reset(),this.#H){const J=Math.min(Number(this.#Q.value)+this.#U,1);if(J===1)this.#H=!1;this.#Q.value=J.toString()}const Q=Math.max(0,Math.min(Number(this.#Q.value),1)),Z=Math.floor(Q*this.alg.length),W=this.cube.executeUntil(this.alg,Z);if(this.#J.set(this.cube),W!==null){const J=Q*this.alg.length-Z;this.#J.animateMove(W,this.ease(J))}else this.#J.clearAnimation()}if(this.render(),this.#H)this.#$()}#V=0;#$(){window.cancelAnimationFrame(this.#V),this.#V=window.requestAnimationFrame(this.update.bind(this))}render(){this.#J.setCameraTransform([0,0,-0.4],this.#G,this.#q),this.#J.render()}#O(Q,Z){if(this.#K===Q&&this.#X===Z)return;this.#K=Q,this.#X=Z,this.#J.resize(Q,Z)}}customElements.define("puzzle-viewer",O0);var z0;(function(r4){function Q(J){switch(J){case 2:return 15;case 3:return 25;case 4:return 40;case 5:return 60;case 6:return 80;case 7:return 100;default:return 0}}function Z(J,K){return J+Math.floor(Math.random()*(K-J))}function W(J,K){const X=Math.floor(J/2),q=J%2===0;if(K===void 0)K=Q(J);const H=[["D","U"],["B","F"],["L","R"]],_=[];Q:for(let k=0;k<K;k++){const T=Z(0,3),O=Z(0,2),L=Z(1,X+(q?O:1));for(let D=k-1;D>=0;D--){if(_[D].index0===T){if(_[D].index1===O&&_[D].width===L){k--;continue Q}continue}break}_.push({index0:T,index1:O,width:L})}return _.map((k)=>{let T=H[k.index0][k.index1];if(k.width>1)if(k.width===2)T+="w";else T=`${k.width}${T}w`;return T+=["","'","2"][Z(0,3)],T}).join(" ")}r4.randomMove=W})(z0||(z0={}));export{G0 as Whitespace,z0 as Scramble,O0 as PuzzleViewer,A as NxNDrawer,o as Move,$0 as FastLSE,V0 as CubeTimer,B as Cube,Q0 as Conjugate,e as Commutator,H0 as Comment,w as CacheCube,_0 as AlgTextarea,U0 as AlgInput,I as Alg};
